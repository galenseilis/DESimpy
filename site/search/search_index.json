{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>DESimpy is a library that provides a minimalist set of components for implementing discrete event simulations.</p>"},{"location":"#quickstart","title":"Quickstart","text":"<p>Install using pip:</p> <pre><code>pip install desimpy\n</code></pre> <p>Now you can prepare a short example like this one:</p> <pre><code>from desimpy import EventScheduler\n\ndef clock(env: EventScheduler, name: str, tick: int | float) -&gt; None:\n    \"\"\"Clock simulation process.\"\"\"\n\n    def action() -&gt; None:\n        \"\"\"Schedule next tick of the clock.\"\"\"\n        print(name, env.current_time)\n        env.timeout(tick, action)\n\n    env.timeout(0, action=action)\n\nenv = EventScheduler()\n\nclock(env, \"fast\", 0.5)\nclock(env, \"slow\", 1)\n\nevent_log = env.run_until_max_time(2)\n</code></pre>"},{"location":"explanation/","title":"Explanation","text":""},{"location":"explanation/#theory","title":"Theory","text":"<p>Discrete event simulation (DES) can be understood through different concepts and formalisms.</p>"},{"location":"explanation/#foo","title":"Foo","text":"<p>DES can be informally broken into a few components:</p> <ul> <li>state: A set of variables representing the way that a system is at some point in time.</li> <li>clock: A variable which keeps track of the simulation time.</li> <li>event list: The sequence of events that have yet to have elapsed in the simulation.</li> <li>random-number generators: instructions to generate pseudorandom numbers.</li> <li>statistics:</li> <li>end condition: the contexts in which the simulation should stop.</li> <li>three-phase approach</li> </ul>"},{"location":"explanation/#devs","title":"DEVS","text":"<p>Coming soon...</p>"},{"location":"explanation/#design","title":"Design","text":"<p>DESimpy was made with certain goals and non-goals in mind. It isn't meant to be everything, and it isn't meant to be nothing. It is meant to give a starting point for a certain audience of computer programmers.</p>"},{"location":"explanation/#goals","title":"Goals","text":"<ul> <li>Provide minimal components for handling times and schedules.<ul> <li>Keep it simple.</li> </ul> </li> <li>Provide a built-in, but optional, event logging system.</li> <li>Follow Di\u00e1taxis framework in developing and maintaining this documentation.</li> </ul>"},{"location":"explanation/#non-goals","title":"Non-Goals","text":"<ul> <li>Provide batteries-included discrete event simulation tools. DESimpy provides the bricks; you must imagine cathedrals.</li> <li>Use coroutines to improve readability or provide asychronous input/output with data sources.</li> <li>Provide pseudorandom number generators.</li> <li>Have events be scheduled in any order other than the time that they elapse.</li> <li>Implementing real-time simulations.</li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/#api-documentation","title":"API Documentation","text":"<p>Coming soon...</p>"},{"location":"reference/#glossary-of-terms","title":"Glossary of Terms","text":"<p>Coming soon...</p>"},{"location":"reference/#examples","title":"Examples","text":"<p>The examples in this section do not have the same pedagogical aims that the tutorials and the guides have. Rather, they only communicate, \"this is a thing that you can do\" rather than trying to guide you to a particular learning.</p>"},{"location":"reference/#simpy-examples","title":"SimPy Examples","text":"<p>We have implemented various examples from the SimPy documentation. They are intended to help communicate to someone already familiar with SimPy how they might equivalently use DESimpy.</p>"},{"location":"reference/#bank-renege","title":"Bank Renege","text":"<pre><code>\"\"\"Implementation of SimPy's Bank Renege example.\n\nsource: https://simpy.readthedocs.io/en/stable/examples/bank_renege.html\n\"\"\"\n\nfrom __future__ import annotations\n\nimport random\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Final\n\nfrom desimpy import Event, EventScheduler\n\n\nRANDOM_SEED: Final[int] = 42\nNEW_CUSTOMERS: Final[int] = 5  # Total number of customers\nINTERVAL_CUSTOMERS: Final[float] = (\n    10.0  # Generate new customers roughly every x seconds\n)\nMIN_PATIENCE: Final[float] = 1.0  # Min. customer patience\nMAX_PATIENCE: Final[float] = 3.0  # Max. customer patience\nCOUNTER_CAPACITY: Final[int] = 1  # Num. customers that can be served in parallel\nTIME_IN_BANK: Final[float] = 12.0  # Time spent in bank\nrandom.seed(RANDOM_SEED)\n\n\n\nclass Counter:\n    \"\"\"A resource representing the bank counter with limited capacity.\n\n    Attributes:\n        env (EventScheduler): The event scheduler.\n        capacity (int): Number of concurrent customers the counter can serve.\n        available (int): Number of available spots at the counter.\n        queue (list): Queue of customers waiting to be served.\n    \"\"\"\n\n    def __init__(self, env: EventScheduler, capacity: int) -&gt; None:\n        self.env: EventScheduler = env\n        self.capacity: int = capacity\n        self.available: int = capacity\n        self.queue = []\n\n    def request(self, customer):\n        \"\"\"Request service for a customer. If there's space, they will be served immediately,\n        otherwise, they join the queue.\n        \"\"\"\n        if self.available &gt; 0:\n            self.available -= 1\n            self.env.schedule(Event(self.env.current_time, customer.start_service))\n        else:\n            self.queue.append(customer)\n            print(f\"{customer.name} is waiting at {self.env.current_time}\")\n\n    def release(self):\n        \"\"\"Release a spot when a customer finishes service. If there are customers in the queue,\n        schedule the next one to be served.\n        \"\"\"\n        self.available += 1\n        if self.queue:\n            next_customer = self.queue.pop(0)\n            self.request(next_customer)\n\n\n\n\nclass Customer:\n    \"\"\"Represents a customer arriving at the bank, with a limited patience.\n\n    Attributes:\n        env (EventScheduler): The event scheduler.\n        name (str): Name of the customer.\n        counter (Counter): The bank counter.\n        patience (float): Maximum time the customer is willing to wait.\n        time_in_bank (float): Time the customer needs for service.\n    \"\"\"\n\n    def __init__(\n        self, env: EventScheduler, name: str, counter: Counter, time_in_bank: float\n    ):\n        self.env = env\n        self.name = name\n        self.counter = counter\n        self.patience = random.uniform(MIN_PATIENCE, MAX_PATIENCE)\n        self.time_in_bank = time_in_bank\n        self.arrive_time = self.env.current_time\n        print(f\"{self.arrive_time:.4f} {self.name}: Here I am\")\n        self.env.schedule(Event(self.arrive_time, self.check_patience))\n\n    def check_patience(self):\n        \"\"\"Check if the customer can be served before their patience runs out.\"\"\"\n        self.counter.request(self)\n        # Schedule reneging event based on the patience\n        self.env.schedule(Event(self.env.current_time + self.patience, self.renege))\n\n    def start_service(self):\n        \"\"\"Start the service at the counter and schedule the finish event.\"\"\"\n        wait_time = self.env.current_time - self.arrive_time\n        print(f\"{self.env.current_time:.4f} {self.name}: Waited {wait_time:.3f}\")\n        service_time = random.expovariate(1.0 / self.time_in_bank)\n        self.env.schedule(\n            Event(self.env.current_time + service_time, self.finish_service)\n        )\n\n    def finish_service(self):\n        \"\"\"Finish the service and leave the bank.\"\"\"\n        print(f\"{self.env.current_time:.4f} {self.name}: Finished\")\n        self.counter.release()\n\n    def renege(self):\n        \"\"\"Reneges if the customer has not been served before their patience runs out.\"\"\"\n        if self in self.counter.queue:\n            self.counter.queue.remove(self)\n            wait_time: float = self.env.current_time - self.arrive_time\n            print(\n                f\"{self.env.current_time:.4f} {self.name}: RENEGED after {wait_time:.3f}\"\n            )\n\n\n\nclass Bank:\n    \"\"\"Simulate the bank, generating customers at random intervals and handling their service.\"\"\"\n\n    # WARN: Not to be confused with `collections.Counter`.\n    def __init__(self, env: EventScheduler, counter: Counter):\n        self.env: EventScheduler = env\n        self.counter: Counter = counter\n\n    def generate_customers(\n        self, num_customers: int, interval: float, time_in_bank: float\n    ):\n        \"\"\"Generate customers at random intervals.\"\"\"\n        for i in range(num_customers):\n            arrival_time = random.expovariate(1.0 / interval)\n            self.env.schedule(\n                Event(\n                    self.env.current_time + arrival_time,\n                    lambda i=i: Customer(\n                        self.env, f\"Customer{i:02d}\", self.counter, time_in_bank\n                    ),\n                )\n            )\n\n\nif __name__ == \"__main__\":\n\n    scheduler = EventScheduler()\n    counter = Counter(scheduler, capacity=COUNTER_CAPACITY)\n    bank = Bank(scheduler, counter)\n    bank.generate_customers(\n        NEW_CUSTOMERS, INTERVAL_CUSTOMERS, time_in_bank=TIME_IN_BANK\n    )\n    _ = scheduler.run_until_max_time(float(\"inf\"), logging=False)\n</code></pre>"},{"location":"reference/#car-class","title":"Car Class","text":"<pre><code>\"\"\"Implementation of SimPy's Car example.\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from typing import Final\n\nfrom desimpy import EventScheduler\n\nLOGGING: Final[bool] = False\nSIMULATION_TIME: Final[float] = 15.0\n\n\nclass Car:\n    \"\"\"A car that alternates between parking/charging and driving in a loop within a simulation environment.\n\n    Upon creation, the car is immediately scheduled to begin its first parking and charging process.\n    After parking and charging, it drives for a fixed time, and then repeats the cycle indefinitely.\n\n    Attributes:\n        env (EventScheduler): The event scheduler that manages simulation events.\n    \"\"\"\n\n    def __init__(self, env: EventScheduler) -&gt; None:\n        \"\"\"Initialize the Car object and schedule the initial run.\n\n        Args:\n            env (EventScheduler): The simulation's event scheduler.\n        \"\"\"\n        self.env: EventScheduler = env\n        # Start the run process when an instance is created\n        self.schedule_run()\n\n    def schedule_run(self) -&gt; None:\n        \"\"\"Schedule the initial parking and charging event.\n\n        This method immediately schedules the first `run` event, with a delay of 0,\n        meaning the parking and charging process will start at the current simulation time.\n        \"\"\"\n        self.env.timeout(0, self.run)\n\n    def run(self) -&gt; None:\n        \"\"\"Handle the parking and charging process, followed by driving.\n\n        When this method is called, the car starts parking and charging. After\n        a fixed charging time of 5 units, the car begins driving. The driving lasts\n        for a fixed duration of 2 units, after which the cycle repeats.\n\n        Prints:\n            A log message indicating the start of parking/charging, followed by a\n            message when driving begins.\n        \"\"\"\n        print(f\"Start parking and charging at {self.env.current_time}\")\n\n        # Define the action to be executed when charging ends\n        def charge_action() -&gt; None:\n            \"\"\"Action to be performed after the charging period ends.\n\n            Once the charging is complete, the car starts driving, and the next\n            parking/charging cycle is scheduled.\n\n            Prints:\n                A log message indicating the start of driving.\n            \"\"\"\n            print(f\"Start driving at {self.env.current_time}\")\n\n            # Schedule the next parking and charging event\n            self.env.timeout(2, self.run)\n\n        # Schedule the charge process\n        self.env.timeout(5, charge_action)\n\n\nif __name__ == \"__main__\":\n    scheduler = EventScheduler()\n    _ = Car(scheduler)\n    _ = scheduler.run_until_max_time(SIMULATION_TIME, logging=LOGGING)\n</code></pre>"},{"location":"reference/#car-driver","title":"Car Driver","text":"<pre><code>from desimpy import Event, EventScheduler\n\nclass Car:\n    def __init__(self, env: EventScheduler) -&gt; None:\n        self.env: EventScheduler = env\n        # Start the run process when an instance is created\n        self.schedule_run()\n\n    def schedule_run(self) -&gt; None:\n        \"\"\"Schedule the initial run event.\"\"\"\n        self.env.timeout(0, self.schedule_charge)\n\n    def schedule_drive(self) -&gt; None:\n        # Define the action to be executed when charging ends\n        print(f\"Start driving at {self.env.current_time}\")\n\n        # Schedule the next parking and charging event\n        self.env.timeout(2, self.schedule_charge)\n\n    def schedule_charge(self) -&gt; None:\n        \"\"\"Handle the parking and charging, followed by driving.\"\"\"\n        print(f\"Start parking and charging at {self.env.current_time}\")\n\n        # Schedule the charge process\n        self.env.timeout(5, self.schedule_drive, context={\"event_type\": \"charge\"})\n\n\ndef deactivate_next_charge_condition(env: EventScheduler, event: Event) -&gt; bool:\n    \"\"\"Deactivate the charging event.\"\"\"\n    _ = env\n    if event.context.get(\"event_type\", None) == \"charge\":\n        return True\n    return False\n\n\ndef driver(env: EventScheduler, car: Car) -&gt; None:\n    def interrupt_action():\n        print(\"Was interrupted. Hope, the battery is full enough ...\")\n        env.deactivate_next_event_by_condition(\n            condition=deactivate_next_charge_condition\n        )\n        event = Event(env.current_time, car.schedule_drive)\n        env.schedule(event)\n\n    env.timeout(3, interrupt_action)\n\n\nif __name__ == \"__main__\":\n    scheduler = EventScheduler()\n    car = Car(scheduler)\n    driver(scheduler, car)\n    _ = scheduler.run_until_max_time(15, logging=False)\n</code></pre>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This tutorial goes through the fundamental components of DESimpy. There are two components of DESimpy that we will focus on: events and event schedulers. Once you know these components you will be ready to jump into building your own simulations or further studying from the topical guides.</p>"},{"location":"tutorial/#events","title":"Events","text":"<p>In this section we're going to go through events in DESimpy.</p>"},{"location":"tutorial/#creating-events","title":"Creating Events","text":"<p>Events can be created explicitly using the <code>Event</code> class. We will see later that we don't always have to make them explicit, but we should know that this is something that can do when needed.</p> <p>Events only require being given the time that they should occur in a simulation. Below we initialize a single event.</p> <pre><code>from desimpy import Event\n\nexample_event = Event(time=2018)\n</code></pre>"},{"location":"tutorial/#event-schedulers","title":"Event Schedulers","text":"<p>Something has to orchestrate events unfolding over time. That's the job of <code>EventScheduler</code>, which we'll cover below.</p>"},{"location":"tutorial/#creating-event-schedulers","title":"Creating Event Schedulers","text":"<p>You can initialize an event scheduler by calling it.</p> <pre><code>from desimpy import EventScheduler\n\nscheduler = EventScheduler()\n</code></pre> <p>Note that the event scheduler does not depend on anything initially. It is intended to be integrated with events, which we'll cover next.</p>"},{"location":"tutorial/#event-schedulers-contain-a-clock","title":"Event Schedulers Contain A Clock","text":"<p>Inside of every event scheduler is a clock that holds the current simulation time. You can access this time with the <code>EventScheduler.now</code> property like in the following example.</p> <pre><code>from desimpy import EventScheduler\n\nscheduler = EventScheduler()\n\nprint(scheduler.now)\n</code></pre> <p>Notice that the result of <code>scheduler.now</code> was zero. The simulation in a new event scheduler is always zero.</p>"},{"location":"tutorial/#scheduling-events","title":"Scheduling Events","text":"<p>Events on their own don't do much. If anything, they're just a glorified way to contain some data and delay a function call <code>Event.run</code>. It is their life cycle within an event scheduler that makes discrete event simulation come to life.</p> <pre><code>from desimpy import Event, EventScheduler\n\nTIME: float = 2018.0\n\nevent = Event(TIME)\nscheduler = EventScheduler()\n\nscheduler.schedule(event)\n</code></pre>"},{"location":"tutorial/#running-a-simulation","title":"Running A Simulation","text":"<p>We have now seen how to create and schedule events. Now it is time for us to create our first simulation. A common way to run a simulation is to call <code>EventScheduler.run_until_max_time</code> which will run the simulation until the specified time.</p> <pre><code>from desimpy import Event, EventScheduler\n\nevent1 = Event(2018, lambda: print(\"It is 2018!\"))\nevent2 = Event(2020, lambda: print(\"It is 2020!\"))\n\nscheduler = EventScheduler()\nscheduler.schedule(event1)\nscheduler.schedule(event2)\n\nscheduler.run_until_max_time(2019)\n</code></pre> <p>Notice that only the <code>\"It is 2018!\"</code> is printed. That is because the simulation is going to stop at 2019, which is between 0 and 2020, but not continue on to 2020.</p>"},{"location":"tutorial/#timeouts","title":"Timeouts","text":"<p>While it isn't bad to define an event explicitly and then schedule it, we can save ourselves a little bit of effort by using the <code>EventScheduler.timeout</code> method.</p> <pre><code>from desimpy import EventScheduler\n\nscheduler = EventScheduler()\n\nscheduler.timeout(2018)\n</code></pre> <p>There is an important difference between using <code>schedule</code> and <code>timeout</code>. The <code>schedule</code> method will take an event with the time that you want the event to elapse. The <code>timeout</code> method will schedule an event that is delayed by the amount of time that you specified. The former is a point in time whereas the latter is a duration following the current time. These two situations look identical when the simulation has not started, but we can now run a simulation to show the difference.</p> <pre><code>from desimpy import Event, EventScheduler\n</code></pre>"}]}